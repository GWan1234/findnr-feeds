#!/usr/bin/env ucode
'use strict';

// å¼•å…¥å¿…è¦çš„åº“ï¼Œå¢åŠ äº† popen ç”¨äºæ‰§è¡Œç³»ç»Ÿå‘½ä»¤
import { stdin, stdout, popen } from 'fs';
import dispatch from 'luci.dispatcher';
import request from 'luci.http';

// åˆå§‹åŒ–å˜é‡
const input_bufsize = 4096;
let content_len = +getenv('CONTENT_LENGTH') || 0;
let buffer = null;
let buffer_pos = 0;

// ==========================================================
// ğŸ›¡ï¸ 2FA æ‹¦æˆªæ ¸å¿ƒé€»è¾‘ (å¼€å§‹)
// ==========================================================

// 1. åªæ‹¦æˆªå°ä½“ç§¯çš„ POST è¯·æ±‚ (é˜²æ­¢æ‹¦æˆªæ–‡ä»¶ä¸Šä¼ å¯¼è‡´å†…å­˜æº¢å‡º)
if (getenv('REQUEST_METHOD') == 'POST' && content_len > 0 && content_len < 10240) {
    // è¯»å–è¯·æ±‚ä½“åˆ°å†…å­˜
    buffer = stdin.read(content_len);
    
    // 2. ç®€å•çš„æ­£åˆ™åŒ¹é…ï¼Œæ£€æŸ¥æ˜¯å¦æ˜¯ root ç™»å½•
    // ä½ çš„æµè§ˆå™¨ payload æ˜¯: luci_username=root
    let user_match = match(buffer, /luci_username=([^&]+)/);
    
    if (user_match && user_match[1] == 'root') {
        // 3. æ£€æŸ¥å¼€å…³çŠ¶æ€ (è°ƒç”¨ uci å‘½ä»¤)
        let p = popen('uci get simple2fa.global.enabled');
        let enabled = p.read('all');
        p.close();
        
        // æ³¨æ„ï¼šå‘½ä»¤è¾“å‡ºé€šå¸¸å¸¦æ¢è¡Œç¬¦ï¼Œéœ€è¦å¤„ç†
        if (enabled && replace(enabled, "\n", "") == '1') {
            
            // 4. è·å–å¯†é’¥
            p = popen('uci get simple2fa.global.secret');
            let secret = p.read('all');
            p.close();
            
            if (secret) {
                secret = replace(secret, "\n", "");
                
                // 5. ä»è¯·æ±‚ä½“ä¸­æå– token (ä½ å‰ç«¯ JS æäº¤çš„å­—æ®µå)
                let token_match = match(buffer, /token=([^&]*)/);
                let token = token_match ? token_match[1] : "";
                
                // 6. è°ƒç”¨ oathtool è®¡ç®—æ­£ç¡®éªŒè¯ç 
                // -b: base32, --totp: ç®—æ³•, -d 6: 6ä½
                p = popen(`oathtool -b --totp -d 6 '${secret}'`);
                let correct_code = p.read('all');
                p.close();
                
                if (correct_code) {
                    correct_code = replace(correct_code, "\n", "");
                    
                    // 7. æœ€ç»ˆæ¯”å¯¹
                    if (token != correct_code) {
                        // âŒ éªŒè¯å¤±è´¥ï¼šé‡å®šå‘å›ç™»å½•é¡µå¹¶å¸¦ä¸Šé”™è¯¯æ ‡è®°
                        print("Status: 302 Found\r\n");
                        print("Location: /cgi-bin/luci?simple2fa_err=1\r\n\r\n");
                        exit(0);
                    }
                }
            }
        }
    }
}
// ==========================================================
// ğŸ›¡ï¸ 2FA æ‹¦æˆªæ ¸å¿ƒé€»è¾‘ (ç»“æŸ)
// ==========================================================


// é‡å†™ read å‡½æ•°ï¼šå¦‚æœæ˜¯ç™»å½•è¯·æ±‚ï¼Œä»å†…å­˜ buffer è¯»å–ï¼›å¦åˆ™ä» stdin æµè¯»å–
function read(len) {
    if (buffer) {
        // ä»å†…å­˜è¯»å– (é’ˆå¯¹ç™»å½•è¯·æ±‚)
        if (buffer_pos >= length(buffer)) return null;
        
        let chunk_len = min(length(buffer) - buffer_pos, len ?? input_bufsize);
        let chunk = substr(buffer, buffer_pos, chunk_len);
        buffer_pos += chunk_len;
        return chunk;
    } else {
        // åŸå§‹æµå¼è¯»å– (é’ˆå¯¹æ–‡ä»¶ä¸Šä¼ ç­‰å…¶ä»–è¯·æ±‚)
        if (content_len <= 0) {
            stdin.close();
            return null;
        }
        
        let chunk = stdin.read(min(content_len, len ?? input_bufsize, input_bufsize));
        if (chunk == null) {
            content_len = 0;
            stdin.close();
        } else {
            content_len -= length(chunk);
        }
        return chunk;
    }
}

function write(data) {
    return stdout.write(data);
}

// æ­£å¸¸åˆ†å‘è¯·æ±‚
let req = request(getenv(), read, write);
dispatch(req);
req.close();